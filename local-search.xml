<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>41.缺失的第一个正数</title>
    <link href="/mimi-blog/2024/10/17/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/mimi-blog/2024/10/17/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h1><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,0]</span><br>输出：3<br>解释：范围 <span class="hljs-comment">[1,2]</span> 中的数字都在数组中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,4,-1,1]</span><br><span class="hljs-string">输出：2</span><br><span class="hljs-string">解释：1 在数组中，但 2 没有。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,8,9,11,12]</span><br>输出：<span class="hljs-number">1</span><br>解释：最小的正数 <span class="hljs-number">1</span> 没有出现。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h2 id="solver"><a href="#solver" class="headerlink" title="solver"></a>solver</h2><ol><li>因为是查找最小缺失的正整数，所以先排序再将小于等于0的过滤掉，再做去重操作。</li><li>最后在无重复正整数中遍历即可，其中在该无重复区间中的每个数的下标需要对应[1,2,3,4,…..]，如果发现不对应的则立即返回start，否则返回数组最大元素+1。</li></ol><h2 id="Coder"><a href="#Coder" class="headerlink" title="Coder"></a>Coder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> i, j, start, index = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 去除复数和重复的数字 双指针</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.length &amp;&amp; nums[i] &lt;= <span class="hljs-number">0</span>; i++, j++) ;<br>        <span class="hljs-keyword">if</span> (i &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        start = i;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[j]) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[j + <span class="hljs-number">1</span>] = nums[i++];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; start &lt;= j; start++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[start] != index) &#123;<br>                <span class="hljs-keyword">return</span> index;<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[nums.length - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>LeetCode</tag>
      
      <tag>去重</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3194.最小元素和最大元素的最小平均值</title>
    <link href="/mimi-blog/2024/10/16/%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/mimi-blog/2024/10/16/%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="3194-最小元素和最大元素的最小平均值"><a href="#3194-最小元素和最大元素的最小平均值" class="headerlink" title="3194. 最小元素和最大元素的最小平均值"></a><a href="https://leetcode.cn/problems/minimum-average-of-smallest-and-largest-elements/">3194. 最小元素和最大元素的最小平均值</a></h1><p>你有一个初始为空的浮点数数组 <code>averages</code>。另给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，其中 <code>n</code> 为偶数。</p><p>你需要重复以下步骤 <code>n / 2</code> 次：</p><ul><li>从 <code>nums</code> 中移除 <strong>最小</strong> 的元素 <code>minElement</code> 和 <strong>最大</strong> 的元素 <code>maxElement</code>。</li><li>将 <code>(minElement + maxElement) / 2</code> 加入到 <code>averages</code> 中。</li></ul><p>返回 <code>averages</code> 中的 <strong>最小</strong> 元素。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong> nums &#x3D; [7,8,3,4,15,13,4,1]</p><p><strong>输出：</strong> 5.5</p><p><strong>解释：</strong></p><table><thead><tr><th>步骤</th><th>nums</th><th>averages</th></tr></thead><tbody><tr><td>0</td><td>[7,8,3,4,15,13,4,1]</td><td>[]</td></tr><tr><td>1</td><td>[7,8,3,4,13,4]</td><td>[8]</td></tr><tr><td>2</td><td>[7,8,4,4]</td><td>[8,8]</td></tr><tr><td>3</td><td>[7,4]</td><td>[8,8,6]</td></tr><tr><td>4</td><td>[]</td><td>[8,8,6,5.5]</td></tr></tbody></table><p>返回 averages 中最小的元素，即 5.5。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong> nums &#x3D; [1,9,8,3,10,5]</p><p><strong>输出：</strong> 5.5</p><p><strong>解释：</strong></p><table><thead><tr><th>步骤</th><th>nums</th><th>averages</th></tr></thead><tbody><tr><td>0</td><td>[1,9,8,3,10,5]</td><td>[]</td></tr><tr><td>1</td><td>[9,8,3,5]</td><td>[5.5]</td></tr><tr><td>2</td><td>[8,5]</td><td>[5.5,6]</td></tr><tr><td>3</td><td>[]</td><td>[5.5,6,6.5]</td></tr></tbody></table><p><strong>示例 3：</strong></p><p><strong>输入：</strong> nums &#x3D; [1,2,3,7,8,9]</p><p><strong>输出：</strong> 5.0</p><p><strong>解释：</strong></p><table><thead><tr><th>步骤</th><th>nums</th><th>averages</th></tr></thead><tbody><tr><td>0</td><td>[1,2,3,7,8,9]</td><td>[]</td></tr><tr><td>1</td><td>[2,3,7,8]</td><td>[5]</td></tr><tr><td>2</td><td>[3,7]</td><td>[5,5]</td></tr><tr><td>3</td><td>[]</td><td>[5,5,5]</td></tr></tbody></table><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n == nums.length &lt;= 50</code></li><li><code>n</code> 为偶数。</li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h2 id="Coder"><a href="#Coder" class="headerlink" title="Coder"></a>Coder</h2><ol><li>双指针 + 排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">minimumAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>; i + <span class="hljs-number">1</span> &lt; j + <span class="hljs-number">1</span>; ) &#123;<br>            res = Math.min((<span class="hljs-type">double</span>) (nums[i++] + nums[j--]) / <span class="hljs-number">2</span>, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM知识体系</title>
    <link href="/mimi-blog/2024/10/16/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-1/"/>
    <url>/mimi-blog/2024/10/16/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-1/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-的整体结构"><a href="#JVM-的整体结构" class="headerlink" title="JVM 的整体结构"></a>JVM 的整体结构</h1><p><strong>JVM 参数文档：</strong><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE"><strong>https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</strong></a></p><ol><li>HotSpot VM 是高性能虚拟机的代表作之一，采用解释器与即时编译并存的架构。</li></ol><ul><li><font style="color:rgba(0, 0, 0, 0.75);">执行引擎包含三部分：</font><code>&lt;font style=&quot;color:#ED740C;background-color:rgb(249, 242, 244);&quot;&gt;解释器&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);">，</font><code>&lt;font style=&quot;color:#ED740C;background-color:rgb(249, 242, 244);&quot;&gt;即时编译器&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);">，</font><code>&lt;font style=&quot;color:#ED740C;background-color:rgb(249, 242, 244);&quot;&gt;垃圾回收器&lt;/font&gt;</code>。</li><li>操作系统只可以识别机器指令，执行引擎充当了高级语言到机器语言的翻译者这样的角色。</li></ul><p><img src="/mimi-blog/image/1725171839512-9dc844f4-84ea-4e7e-8c23-7c0d88b9428b.png"></p><h2 id="Java-代码的执行流程"><a href="#Java-代码的执行流程" class="headerlink" title="Java 代码的执行流程"></a>Java 代码的执行流程</h2><p><img src="/mimi-blog/image/1725172491547-5345e450-bf53-429d-b0e1-017475f6242b.png"></p><h2 id="JVM-架构模型"><a href="#JVM-架构模型" class="headerlink" title="JVM 架构模型"></a>JVM 架构模型</h2><ol><li>Java 编译器输入的指令基本上基于<code>&lt;font style=&quot;color:#ECAA04;&quot;&gt;栈的指令级架构&lt;/font&gt;</code>，另外一种指令集架构则是基于<code>&lt;font style=&quot;color:#ECAA04;&quot;&gt;寄存器的指令集架构&lt;/font&gt;</code>。</li><li>基于栈式架构的特点：<ol><li>设计实现更简单，适用于资源受限的系统。</li><li>避开了寄存器的分配难题，使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作站。指令级更小，编译器容易实现。</li><li>不需要硬件支持，可以执行性更好，更好的实现跨平台。</li></ol></li><li>基于寄存器架构的特点:<ol><li>应用 x86 的二进制指令级。</li><li>指令级架构依赖硬件，可移植性差。</li><li>执行指令操作花费时间更少。</li><li>大部分情况下，基于寄存器架构的指令集王往都是一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ol></li><li>以下为两种方式的指令差别：2+3</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_2<br><span class="hljs-number">1</span>: istore_1<br><span class="hljs-number">2</span>: iconst_3<br><span class="hljs-number">3</span>: istore_2<br><span class="hljs-number">4</span>: iload_1<br><span class="hljs-number">5</span>: iload_2<br><span class="hljs-number">6</span>: iadd<br><span class="hljs-number">7</span>: istore_3<br><br><br>mov eax, <span class="hljs-number">2</span><br>add eax, <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ol start="5"><li>总结：栈式架构具有跨平台性，Java 指令都是根据栈来设计（<code>&lt;font style=&quot;color:#ECAA04;&quot;&gt;跨平台、指令级小、指令多、性能比寄存器稍微差一点&lt;/font&gt;</code>）。</li></ol><h2 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a>JVM 生命周期</h2><ol><li><strong>虚拟机启动：</strong><ol><li>虚拟机启动是通过<code>&lt;font style=&quot;color:#ECAA04;&quot;&gt;引导类加载器（Bootstrap Class Loader）&lt;/font&gt;</code>创建一个初始类（<code>&lt;font style=&quot;color:#ECAA04;&quot;&gt;Initial Class&lt;/font&gt;</code>）来完成，这个类是由虚拟机的具体实现指定的。</li><li>启动时会加载很多的类，Object 类是通过引导类加载器加载的。</li></ol></li><li><strong>虚拟机执行：</strong><ol><li>运行中的 Java 虚拟机有着一个清晰的任务（Java 程序）。</li><li>程序开始执行时都会启动一个 Java 虚拟机进程， 当 Java 进程结束时就停止。</li></ol></li><li><strong>虚拟机结束：</strong><ol><li>程序正常结束。</li><li>程序在执行过程中遇到 Exception 或者 Errot 而终止。</li><li>操作系统出现致命错误导致 Java 虚拟机进程终止。</li><li>某线程调用 Runtime 的 System 的 exit 方法，或者 System 的 halt 方法，并且 Java 安全管理器（SecurityManager）也允许这次 exit 或者 halt 操作。</li></ol></li></ol><h2 id="JVM-发展历程"><a href="#JVM-发展历程" class="headerlink" title="JVM 发展历程"></a>JVM 发展历程</h2><ol><li>1996 年 Java1.0（Sun Classic NM），第一宽商用虚拟机，Java1.4 后被淘汰，HotSpot 内置了该虚拟机。<ol><li>只提供了解释器。</li><li>JIT 为即时编译器，在此版本中不可以系统工作，只可以二选一。</li></ol></li><li>Exact VM。<ol><li>为了解决上一个虚拟机的问题，JDK1.2 时 SUN 提供了此虚拟机。</li><li>可以直到内存中某个位置的数据具体是什么类型。</li><li>可以进行热点探测（热点代码即时编译），编译器与解释器协同工作。</li><li>被 HotSpot 虚拟机替换。</li></ol></li><li>SUN（HotSpot VM）。<ol><li>早期由（Longview Technologies）小公司设计。1997 年被 SUN 收购，2009 年 SUN 被甲骨文收购。</li><li>应用较为广泛，服务器、桌面、嵌入式等。</li><li>比较好的热点代码即使编译，进行栈上替换。</li><li>编译器和解释器可协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li></ol></li><li>BEA 的 JRockit。<ol><li>专注于服务器端应用，因此不包含解析器的实现，全部代码依靠即时编译器执行。</li><li>JRockit 是最快的 JVM。</li><li>对延迟敏感的应用也有对应的解决方案（JRockit Real Time）。</li></ol></li><li>IBM J9。<ol><li>IBM Technology for Java Virtual Machine，简称 IT4J，内部代号 J9。</li><li>与 HotSpot 接近，应用场景相似。</li><li>广泛应用于 IBM 的产品。</li></ol></li><li>KVM 和 CDC&#x2F;CLDC HotSpot。<ol><li>Oracle 在 Java ME 产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM。</li><li>KVM 是 CLDC-HI 早期产品。</li><li>KVM 简单、清凉、高度可以指，面向更低端的设备上还维护自己的市场。</li></ol></li><li>Azul VM。</li></ol><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><p><img src="/mimi-blog/image/1725176644428-ba84bc91-79ef-4f9b-8e2a-81bcdfedf7d1.png"></p><h1 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1><ol><li>类加载子系统复杂从文件系统或者网络中加载 class 文件，class 文件在文件开头有特定的文件标识。</li><li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 ExecutionEngine 决定。<ol><li>从另一个概念上理解，要期末考试了，我只负责做卷子，做完对不对那就不是我的问题了，那就是判卷人的问题了。</li></ol></li><li>加载的类信息存放于一块成为方法区的内存空间，除了类的信息外，方法去中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）。</li></ol><p><img src="/mimi-blog/image/1725177136892-95e12f18-da16-4361-8c06-9d21603878a9.png"></p><ol start="4"><li>类的加载过程：<ol><li>通过一个类的全限定名称，获取定义类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;在内存中生成一个代表这个类的 java.lang.Class 对象&lt;/font&gt;</code>，作为方法区这个类的各种数据的访问入口。</li><li>加载 class 文件的方式：<ol><li>在本地系统中直接加载</li><li>通过网络获取，典型场景 Web Applet</li><li>从 zip 压缩包中读取，成为 jar、war 格式的基础</li><li>运行时计算生成，使用最多的就是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;动态代理&lt;/font&gt;</code>。</li><li>由其他文件生成，典型场景<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;JSP 应用&lt;/font&gt;</code>。</li><li>从专门数据库中提取 class 文件。</li><li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施。</li></ol></li></ol></li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol><li>验证（Verify）：确保 Class 文件的字节流包含信息符合当前虚拟机要求，保证加载类的正确性，不危害虚拟机自身安全，（ca fe ba be 二进制文件头部字样）。<ol><li>主要包括四种验证：<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;文件格式验证&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;元数据验证&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;字节码验证&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;符号引用验证&lt;/font&gt;</code>。</li></ol></li><li>准备（Prepare）：为类变量分配欸村并设置类变量的默认初始值（int -&gt; 0, boolean -&gt; false 等）。<ol><li>不包含 final 修饰的 static，因为 final 在编译时就已经分配了，准备阶段会显示初始化。</li><li>不会为实例变量分配初始化，类变量分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆（Heap）中。</li></ol></li><li>解析（Resolve）：将常量池中的符号引用转换为直接引用过程。<ol><li>在 JVM 在执行初始化之后再执行，符号引用就是一组符号描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 class 文件格式中。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。</li><li>解析动作主要针对<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;接口、字段、类方法、接口方法、方法类型&lt;/font&gt;</code>等。对应常量池中<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;CONSTANT_Class_info、CONSTANT_Fielderf_info、CONSTANT_Methodref_info&lt;/font&gt;</code>等。</li></ol></li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol><li>执行器执行类构造方法<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;clinit&gt;()&lt;/font&gt;</code>的过程。<ol><li><clinit>()方法不需要定义出来，是 javac 编译器自动收集类中的所有类变量的赋值动作以及静态代码块的语句合并而来。</li></ol></li></ol><p><img src="/mimi-blog/image/1725178945821-7a864529-db11-4f62-b68c-041f06b83395.png"></p><pre><code class="hljs">2. 按照 class 文件的上下顺序覆盖的值。    1. 以下代码 NUMBER 的初始化顺序为：NUMBER -&gt; 0 -&gt; 20 -&gt; 10;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        I = <span class="hljs-number">2</span>;<br>        NUMBER = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(NUMBER + <span class="hljs-string">&quot; &quot;</span> + I);<br>    &#125;<br>&#125;<br><br><span class="hljs-number">0</span> iconst_1<br><span class="hljs-number">1</span> putstatic #<span class="hljs-number">9</span> &lt;Main.I : I&gt;<br><span class="hljs-number">4</span> iconst_2<br><span class="hljs-number">5</span> putstatic #<span class="hljs-number">9</span> &lt;Main.I : I&gt;<br><span class="hljs-number">8</span> bipush <span class="hljs-number">20</span><br><span class="hljs-number">10</span> putstatic #<span class="hljs-number">5</span> &lt;Main.NUMBER : I&gt;<br><span class="hljs-number">13</span> bipush <span class="hljs-number">10</span><br><span class="hljs-number">15</span> putstatic #<span class="hljs-number">5</span> &lt;Main.NUMBER : I&gt;<br><span class="hljs-number">18</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;clinit&gt;()&lt;/font&gt;</code>不同于类的构造器，构造器是虚拟机视角下的<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;init&gt;()&lt;/font&gt;</code>，若该类具有父类，JVM 保证子类的 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;clinit&gt;()&lt;/font&gt;</code>执行前，父类的<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;clinit&gt;()&lt;/font&gt;</code>已经执行完毕。</li><li>虚拟机必须保证一个类的<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;&lt;clinit&gt;()&lt;/font&gt;</code>方法在多线程下被同步加锁。<ol><li><clinit>()方法是属于类的，所以当多线程执行<clinit>()时需要保证只有一个线程执行<clinit>()方法，同不加锁。</li></ol></li></ol><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ol><li>分为<code>引导类加载器（Bootstrap Class Loader）</code>、<code>自定义类加载器（User-Defined ClassLoader）</code>。</li><li>自定义类加载器由开发人员自定义的类加载器。</li><li>User Defined Class Loader 不是上下层关系（继承关系），是包含的关系。</li><li>String 类是由<code>Bootstrap Class Loader</code>加载器加载的，自定义类的类加载器是由<code>System Class Loader</code>加载的。</li><li>其中 Bootstrap Class Loader 加载器是获取不到的，其他的加载器可以通过<code>.parent()</code>的形式获取到。</li></ol><p><img src="/mimi-blog/image/1725180293972-48d4076b-28f7-43f5-84c0-ee7b3ef6d98e.png"></p><h3 id="Bootstrap-Class-Loader"><a href="#Bootstrap-Class-Loader" class="headerlink" title="Bootstrap Class Loader"></a>Bootstrap Class Loader</h3><ol><li>使用<code>C/C++实现</code>，嵌套在 JVM 内部。</li><li>用来加载 Java 的核心库（Java home ‘&#x2F;jre&#x2F;lib&#x2F;rt.jar’）。resources.jar 或者 sun.boot.class.path 路径下的内容，用于提供 JVM 自身需要的类。</li><li>不继承 java.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为父类加载器。</li><li>Bootstrap 启动类加载器只加载 java、javax、sun 开头的类（处于安全考虑）。</li></ol><h3 id="Extension-Class-Loader"><a href="#Extension-Class-Loader" class="headerlink" title="Extension Class Loader"></a>Extension Class Loader</h3><ol><li>Java 语言编写的，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类。</li><li>父类为 BootstrapClassLoader。</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，从 JDK 的安装目录<code>jre/lib/ext</code>子目录下加载类库。如果用户创建的 JAR 放在此目录下就会被加载。</li></ol><h3 id="App-Class-Loader"><a href="#App-Class-Loader" class="headerlink" title="App Class Loader"></a>App Class Loader</h3><ol><li>Java 语言编写的，由 sun.misc.Launcher$AppClassLoader 实现。</li><li>父类为 ClassLoder。</li><li>父类加载器为扩展类加载器，负责加载环境变量 classpath 或者系统属性 java.class.path 指定路径下的类库。</li><li>是程序中默认的类加载器，Java 应用类的类加载器都是由它来完成的。</li><li>通过<code>ClassLoader.getSystemClassLoader()</code>获取。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> sun.misc.Launcher;<br><br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 小猫儿老板</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2024-9-1 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL urL : urLs) &#123;<br>            System.out.println(urL);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=========================================================&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : property.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/resources.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/rt.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/sunrsasign.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/jsse.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/jce.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/charsets.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/lib/jfr.jar<br>file:/C:/Program%20Files%20(x86)/Java/jdk1.8.0_281/jre/classes<br>=========================================================<br>C:\Program Files (x86)\Java\jdk1.8.0_281\jre\lib\ext<br>C:\Windows\Sun\Java\lib\ext<br></code></pre></td></tr></table></figure><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><ol><li>通过继承 java.lang.ClassLoader 类，实现自己的类加载器，满足特殊需求。</li><li>在 JDK1.2 之前，自定义类加载器，总会继承 ClassLoader 类并重写 loadClass()方法，从而实现自定义的类加载，<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;JDK1.2 之后不建议覆盖 loadClass 方法，而是建议把自定义的类加载逻辑写入 findClass()方法中&lt;/font&gt;</code>。</li><li>编写自定义类加载器时，如果不是太复杂的需求，可以直接继承 URLClassLoader，可以避免自行编写 findClass 方法以及获取字节码流的方式，使得自定义类加载器更加简洁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; one = Class.forName(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-literal">true</span>, ClassLoaderTest1.class.getClassLoader());<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> one.newInstance();<br>            System.out.println(o.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">byte</span>[] bit = getClassFromClassLoaderPath(name);<br>            <span class="hljs-keyword">if</span> (bit == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>            &#125;<br>            <span class="hljs-keyword">return</span> defineClass(name, bit, <span class="hljs-number">0</span>, bit.length);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromClassLoaderPath(String name) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ol><li>Java 虚拟机对 class 文件采用<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;按需加载&lt;/font&gt;</code>的方式，当需要使用该类时才会将它的 class 文件加载到内存中生成 class 对象。加载这个 class 类时用的就是<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;双亲委派机制&lt;/font&gt;</code>，<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;把请求交给父类处理，是一种任务委派机制&lt;/font&gt;</code>。</li><li>优势：<ol><li>保证类不被重复加载。</li><li>保证类不被篡改，防止核心 API 不被篡改。</li></ol></li></ol><p><img src="/mimi-blog/image/1725184819263-d25af38b-7638-4a3f-8bf3-db5460a1f661.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol><li>BootstrapClassLoader 加载 java&#x2F;javax 开头的限定类，当外界试图创建一个以这些限定类开头的包达到让BootstrapClassLoader 加载来破坏核心 API 的目的，这种情况是不可能的，也是不允许发生的，当我们在 java.lang 包下创建一个自己类，就会出现<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;java.lang.SecurityException: Prohibited package name: java.lang&lt;/font&gt;</code><font style="color:#000000;">的一个错误信息。这样就是沙箱安全机制。</font></li></ol><p><font style="color:#000000;"></font></p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><font style="color:#000000;">运行时数据区</font></h1><ol><li>内存是硬盘和 CPU 的中间仓库以及桥梁，承载操作系统和 APP 的实时运行。JVM 内存布局规定 Java 在内存的申请、管理、分配策略，保证 JVM 高效稳定的原型。</li><li>其中<font style="color:#ED740C;">方法区、堆</font>是一个进程中一份，<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;程序计数器、本地方法栈、虚拟机栈&lt;/font&gt;</code>是一个线程一份。</li><li>每一个 Java 应用程序存在一个 Runtime 实例，用于接口环境之间的交互操作，可以通过 getRuntime()方法获取。</li></ol><p><img src="/mimi-blog/image/1725185662452-4d61ac0d-f610-4053-b34f-391e15d07ff4.png"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ol><li>线程中是应用程序的运行单元，JVM 支持多线程并行执行。在 HotSpot JVM 中每个线程都与操作系统的本地线程直接映射。</li><li>当一个 Java 线程准备好执行时，本地线程也就创建了，当 Java 线程结束时，本地线程也就结束了。</li><li>Java 中使用 Thread 类创建一个线程，start 方法会调用本地方法 start0 对本地线程进行创建，然后开始 run 方法。</li><li>后台系统线程在 HotspotJVM 中主要有以下几个：<ol><li><strong>虚拟机线程</strong>：需要 JVM 达到安全点时才会出现，这种线程执行类型包括“stop-the-world”的垃圾收集、线程栈手机、线程挂起、偏向锁撤销。</li><li><strong>周期任务线程</strong>：一般用于周期性操作的调度执行。</li><li><strong>GC 线程</strong>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li><strong>信号调度线程</strong>：收集信号并发给 JVM，内部通过调用适当的方法进行处理。</li></ol></li></ol><h3 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h3><ol><li>CPU 时间片就是 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作时间片。</li><li>宏观上可以同时打开多个应用程序，每个程序并行不悖，同时在进行。微观上只有一个 CPU，一个只能处理程序要求的一部分，引入时间片每个程序轮流执行，因为 CPU 时间片是很短的每个在 10-50 毫秒不等，所以在感觉上像是好几个程序在并行执行，实则在底层是并发执行的。</li></ol><h2 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h2><ol><li>程序寄存器用来存储指令指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li></ol><p><img src="/mimi-blog/image/1725270236869-4dece1de-4e63-44d0-a769-880a4c3c9c05.png"></p><ol start="2"><li>PC 计数器是一块儿很小的内存空间，几乎可以忽略不计，运行速度最快的存储区域。</li><li>每个线程都有自己的程序计数器，是线程私有的，生命周期于线程的生命周期保持一致。</li><li>PC 寄存器是控制流的<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;指示器&lt;/font&gt;</code>，<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;分支&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;循环&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;跳转&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;异常处理&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;线程恢复&lt;/font&gt;</code>等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作就是通过改变计数器的值来选七下一条需要执行的字节码指令。</li><li>在 Java VM 规范中没有规定 OOM 的情况区域。</li></ol><h3 id="字节码说明"><a href="#字节码说明" class="headerlink" title="字节码说明"></a>字节码说明</h3><ol><li>其中最前面的一列为<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;指令地址&lt;/font&gt;</code>或者<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;偏移地址&lt;/font&gt;</code>。</li><li>后面的像 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;bipush&lt;/font&gt;</code> 都是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;操作指令&lt;/font&gt;</code>。</li><li>当执行了一次 <code>i = 10; j = 20; k = i + j;</code>这样的操作时字节码文件就如下面所示，其中 PC 寄存器做的事情就是记录当前程序执行的位置。</li><li>PC 寄存器记录指令的执行位置是为了在发生线程切换时，记录当前线程执行的情况，以免后续线程再次切换回来时指令的错误执行问题。</li></ol><p><img src="/mimi-blog/image/1725271414659-7fdf41b5-65ad-47d2-bf50-6a83b1a5eee5.png"></p><ol start="5"><li>PC 寄存器在每个线程中又有一份而且是私有的，这是每个线程都有自己对这段代码的执行情况，所以需要记录在自己的线程栈信息中，如果是共享的那就乱套了。</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ol><li><font style="color:#ED740C;">栈是运行时单位，堆是存储的单位</font>。<ol><li>栈解决程序的运行问题，即程序如何执行。</li><li>堆解决数据存储的问题，数据放在那里、应该怎么放。</li></ol></li><li>JVM 会为每个线程分配一个独立的虚拟机栈，用于存放执行的方法。<ol><li>分配的虚拟机栈帧的生命周期是和线程保持一致的。</li><li>主管 Java 程序的运行，保存方法的<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;局部变量（8 种基本类型、对象引用地址）&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;部分结果&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;并参与方法的调用和返回&lt;/font&gt;</code>。</li></ol></li><li>栈是一种快速有效的分配存储方式，访问速度几次与程序计数器（pop 和 push）的操作。<ol><li>没执行一个方法时就会将方法压栈（pop）。</li><li>当方法执行完毕时就会将方法出栈（push）。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;不存在垃圾回收问题&lt;/font&gt;</code>。</li></ol></li><li>栈是存在 OOM 的，就比如子弹夹总有满的时候。</li><li><code>-Xss</code>设置 JVM 运行时栈的大小，<code>-Xss256k</code>结果打印的 count&#x3D;2453。</li></ol><p><img src="/mimi-blog/image/1725275815444-223e127d-bceb-47c4-bcf7-60214c9612e7.png"></p><ol start="6"><li>每个线程都有自己的栈，栈中数据都是以栈帧（Stack Frame）的格式存在的。执行的每个方法都对应了一个栈帧（Stack Frame）。站真是一个内存区域，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈内部结构"><a href="#栈内部结构" class="headerlink" title="栈内部结构"></a>栈内部结构</h3><ol><li>局部变量表（Local Variables）。</li><li>操作数栈（Operand Stack）。</li><li>动态链接（Dynamic Linking）（指向运行时常量池的方法引用）。</li><li>方法返回地址（Return Address）（方法正常退出或者异常退出的定义）。</li><li>一些附加信息。</li></ol><p><img src="/mimi-blog/image/1725277088332-4b3c4875-c38d-4f83-b0a2-c9c1ed65d116.png"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ol><li>局部变量表是一个<code>数字数组</code>，用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括<code>基本类型</code>、<code>对象引用</code>以及<code>return Address</code>类型。</li><li>其中本地变量表情况中的 length 指的是，从起始 PC 开始的 length 行内有效。</li></ol><p><img src="/mimi-blog/image/1725279071000-2bc0d2e0-64c0-4b30-986d-10cb28b8f7b7.png"></p><ol start="3"><li>JVM 会为局部变量表中的每一个 slot 分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>如果需要访问局部变量中一个 64bit 的变量时，只需要访问第一个 slot 即可（long、double）。</li></ol><p><img src="/mimi-blog/image/1725280006681-558cd41c-c8d1-4e1f-9b4d-7c67e9d359cc.png"></p><ol start="5"><li>如果是实例方法局部变量表中会自动添加一个 this 变量，在 static 中的变量表中没有 this 变量所以 static 中不可以使用 this 关键字。</li><li>索引的重复利用机制：当一个代码块内声明的局部变量消失后，后续变量将占用它的 slot，这里变量 b 在 if 中声明，逃出 if 后就不起作用了，所以 变量 c 也站在了索引为 2 的表格中。</li></ol><p><img src="/mimi-blog/image/1725280184367-c623fb7f-488e-421c-8a12-86f2d2f912c2.png"></p><ol start="7"><li>变量的分类：在使用前都会被默认赋值。<ol><li>数据类型（基本、引用）</li><li>位置（类、实例、局部）<ol><li>成员变量：在 linking 的 prepare 阶段给类变量默认值，initial 阶段给类变量或者静态代码块<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;显示赋值&lt;/font&gt;</code>。</li><li>局部变量：不会进行默认赋值，所以在使用前必须进行赋值。</li></ol></li></ol></li></ol><p>:::color2<br>栈帧中，与性能调优关系最为密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><p>:::</p><h3 id="操作数栈（Expression-Stack）"><a href="#操作数栈（Expression-Stack）" class="headerlink" title="操作数栈（Expression Stack）"></a>操作数栈（Expression Stack）</h3><ol><li>栈可以通过数组和链表来进行设计，只要遵循 FILO 特性即可。</li><li>在方法执行过程中，根据字节码指令，往栈中写入数据或者提取数据，即入栈和出栈。</li></ol><p><img src="/mimi-blog/image/1725281816847-1a4f7ccf-a0e1-4a85-8c64-11d6f609db25.png"></p><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><ol><li>栈式结构，指令集小但是指令会很多，因为是基于栈的架构，所以栈的指令是较多的。</li><li>将栈顶元素全部缓存到 CPU 的寄存器中，依次降低对内存的读写次数，提升执行引擎的执行效率。</li></ol><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><ol><li>每一个栈帧内部都包含一个指向<code>运行时常量池 Constant Pool</code>中<code>该栈帧所属方法的引用</code>包含这个引用的目的就是为了支持当前方法的代码能够实现<code>动态链接（Dynamic Linking）</code>，比如<code>invokeddynamic</code>指令。</li><li>Java 源文件被编译到字节码文件中时，变量和方法引用都作为符号引用<code>#xx;#xx</code>保存在 class 文件的常量池中指向方法的符号引用来表示的，<code>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span><br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SUPER<br>  this_class: #<span class="hljs-number">5</span>                          <span class="hljs-comment">// DynamicLinkingTest</span><br>  super_class: #<span class="hljs-number">6</span>                         <span class="hljs-comment">// java/lang/Object</span><br>  interfaces: <span class="hljs-number">0</span>, fields: <span class="hljs-number">0</span>, methods: <span class="hljs-number">3</span>, attributes: <span class="hljs-number">1</span><br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">21</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">22.</span>#<span class="hljs-number">23</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">24</span>            <span class="hljs-comment">// aaa</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">27</span>            <span class="hljs-comment">// DynamicLinkingTest</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">28</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">13</span> = Utf8               LDynamicLinkingTest;<br>  #<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               method<br>  #<span class="hljs-number">19</span> = Utf8               SourceFile<br>  #<span class="hljs-number">20</span> = Utf8               DynamicLinkingTest.java<br>  #<span class="hljs-number">21</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">22</span> = Class              #<span class="hljs-number">29</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">30</span>:#<span class="hljs-number">31</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">24</span> = Utf8               aaa<br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">33</span>:#<span class="hljs-number">34</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">27</span> = Utf8               DynamicLinkingTest<br>  #<span class="hljs-number">28</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">29</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">30</span> = Utf8               out<br>  #<span class="hljs-number">31</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">32</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">33</span> = Utf8               println<br>  #<span class="hljs-number">34</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicLinkingTest</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   LDynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String aaa</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><ol><li>存放调用该方法的 PC 寄存器的值。</li><li>方法返回地址 PC 寄存器用于记录当出现方法调用时，PC 寄存器就会记录该方法正常退出的下一条指令的地址。</li></ol><p><img src="/mimi-blog/image/1725328643768-8c91bbd1-e859-4271-9da8-05fb352afbc9.png"></p><ol start="3"><li>方法返回具体需要哪一个返回指令，这是根据方法返回值类型来定的。<ol><li>ireturn：boolean、byte、char、short、int。</li><li>lreturn、freturn、dreturn、areturn，另外还有 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;return 指令仅供 void&lt;/font&gt;</code> 返回值方法、实例初始化方法、类和接口的初始化方法使用。</li></ol></li></ol><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><ol><li>看 Java 具体的虚拟机。</li></ol><h2 id="绑定问题"><a href="#绑定问题" class="headerlink" title="绑定问题"></a>绑定问题</h2><ol><li>静态链接：如果被调用的目标方法在编译期可知，其运行期保持不变时，这种情况下调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li>动态链接：如果被调用的方法无法在编译器被确定下来，在运行期间将调用方法的符号引用转换为直接引用，这种引用转换过程具备动态链接行。</li><li>非虚方法：在编译期间确定了具体掉用，运行时是不可变的就是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;非虚方法&lt;/font&gt;</code>。<ol><li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。</li><li>其他都是虚方法。</li></ol></li></ol><h3 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h3><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本。</li><li>invokespecial：调用<init>方法，私有以及父类<inti>方法，解析阶段确定唯一方法版本。</li><li>invokevirtual：调用所有虚方法。如果目标方法是一个 final，但是没有通过显示的调用就认为是一个 invokevirtual 虚方法，但实际上是属于非虚方法的。</li><li>invokeinterface：调用接口方法。</li></ol><h3 id="动态调用指令"><a href="#动态调用指令" class="headerlink" title="动态调用指令"></a>动态调用指令</h3><ol><li>invokedynamic：动态解析出需要调用的方法，然后执行。</li></ol><h3 id="静动区别"><a href="#静动区别" class="headerlink" title="静动区别"></a>静动区别</h3><ol><li>Java 属于静态语言，在编译期间就要确定下来类型。</li><li>JavaScript 和 python 就属于动态语言了，在编译期间不需要确定具体类型，例如<code>var a = 12 或者  info = 12</code>。</li></ol><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><ol><li>lambda 表达式使用的指令就是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;invokedynamic&lt;/font&gt;</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Lambda</span> <span class="hljs-variable">lambda</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lambda</span>();<br>        <span class="hljs-type">Fun</span> <span class="hljs-variable">fun</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        lambda.fun(fun);<br>        lambda.fun(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fun</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Fun fun)</span> &#123;<br>        fun.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;Lambda&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;Lambda.&lt;init&gt; : ()V&gt;<br> <span class="hljs-number">7</span> astore_1<br> <span class="hljs-number">8</span> invokedynamic #<span class="hljs-number">4</span> &lt;run, BootstrapMethods #<span class="hljs-number">0</span>&gt;<br><span class="hljs-number">13</span> astore_2<br><span class="hljs-number">14</span> aload_1<br><span class="hljs-number">15</span> aload_2<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">5</span> &lt;Lambda.fun : (LFun;)V&gt;<br><span class="hljs-number">19</span> aload_1<br><span class="hljs-number">20</span> invokedynamic #<span class="hljs-number">6</span> &lt;run, BootstrapMethods #<span class="hljs-number">1</span>&gt;<br><span class="hljs-number">25</span> invokevirtual #<span class="hljs-number">5</span> &lt;Lambda.fun : (LFun;)V&gt;<br><span class="hljs-number">28</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li>为了提高性能，内部创建了一个<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;虚方法表&lt;/font&gt;</code>，非虚方法不会出现在虚方法表中也不会为其创建，因为在编译器就已经确定了其具体的方法。</li><li>每个类都有一个虚方法表，表格中存放着各个方法的实际入口。</li><li>虚方法表会在类加载的<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;链接阶段创建并开始初始化&lt;/font&gt;</code>，类的变量初始值准备完成之后，JVM 会把该类的方法表页初始化完毕。</li></ol><p><img src="/mimi-blog/image/1725328282818-7b050e5f-c0ba-4148-9f9a-20fe40b32923.png"></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ol><li>本地方法栈用于管理本地方法的调用。</li><li>本地方法是私有的，也是线程私有的。</li></ol><h2 id="堆-（Heap）"><a href="#堆-（Heap）" class="headerlink" title="堆 （Heap）"></a>堆 （Heap）</h2><ol><li>JVM 实例只存在一个堆（Heap）内存，堆也是 Java 内存管理的核心区域。</li><li>Java 堆区在 JVM 启动时就被创建，其空间大小也就确定了，时 JVM 管理的最大一块儿内存空间了，也是最重要的一块儿内存空间。</li><li>堆内存空间大小可以调节，通过 VM 指令。</li><li>所有的线程共享 Java 堆，内部还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB）。</li><li>所有对象实例以及数据都应该在运行时分配在<code>堆（Heap）</code>上。</li><li>堆中的对象在 GC 垃圾回收器触发时才会被销毁，并不是在某个引用不再指向时就立即销毁。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/45356455/1725331956027-f249fde7-f0f4-438c-9253-3d86bce53d99.png"></p><h3 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h3><ol><li>Java7 及以前，在逻辑上分成了三个部分（新生区、养老区、永久区）。<ol><li>Young Generation Space（Young GC）。</li><li>Tenure Generation Space （Old）。</li><li>Permanent Space（Perm）。</li></ol></li><li>Java8 及以后堆内存在逻辑上分为了三个部分，（新生区、养老区、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;元空间&lt;/font&gt;</code>）。<ol><li>Young Generation Space（Young GC）。</li><li>Tenure Generation Space （Old）。</li><li>Meta Space（Meta）。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/45356455/1725332805328-2e0c8ba1-ea93-467a-927e-684ad520cd64.png"></p><h3 id="堆空间的设置"><a href="#堆空间的设置" class="headerlink" title="堆空间的设置"></a>堆空间的设置</h3><ol><li><code>-Xms</code>用于表示堆区的起始内存，等价于<code>-XX:InitiaHeapSize</code>。<ol><li>-X 表示 JVM 的运行参数。</li><li>ms （memory start）。</li></ol></li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code>。</li><li>开发期间建议将初始<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;堆内存&lt;/font&gt;</code>和<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;最大的堆内存&lt;/font&gt;</code>保持一致。</li><li>默认对空间大小：<ol><li>初始内存：物理电脑内存大小 &#x2F; 64。</li><li>最大内存大小：物理电脑内存大小 &#x2F; 4。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> runtime.totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> runtime.maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;初始内存 = &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最大内存 = &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;初始堆内存占用: &quot;</span> + initialMemory * <span class="hljs-number">64.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最大堆内存占用: &quot;</span> + maxMemory * <span class="hljs-number">4.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br><br>    &#125;<br>&#125;<br>初始内存 = 245M<br>最大内存 = 3621M<br>初始堆内存占用: <span class="hljs-number">15.</span>3125G<br>最大堆内存占用: <span class="hljs-number">14.</span>14453125G<br></code></pre></td></tr></table></figure><ol start="5"><li>使用 JSP 命令得到对应的<code>线程 ID</code>，使用 JSTAT -GC [ID] 查看堆中的使用情况。<ol><li><code>-Xms600m -Xms600m -XX:+PrintGCDetails</code>在程序运行时设置的 VM 参数。</li><li>求证：（25600+153600+409600）&#x2F; 1024 &#x3D; 575M。</li><li>设置了 600m 为什么时 575M 呢，这是因为 S0 和 S1 只需要记录一个，加上之后就是 600 M 了。</li></ol></li></ol><p><img src="/mimi-blog/image/1725334820913-fde1c786-a3c6-4563-aa01-1ee0d3112bc9.png"></p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><ol><li>当 Old 和 Eden 满时，就会出现 OOM Error。</li></ol><p><img src="/mimi-blog/image/1725338928024-fd1d4409-be53-43df-9eea-a6e9459fc26f.png"></p><h3 id="比例设定"><a href="#比例设定" class="headerlink" title="比例设定"></a>比例设定</h3><ol><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:NewRatio&lt;/font&gt;</code>设置<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;新生代&lt;/font&gt;</code>与<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;老年代&lt;/font&gt;</code>的比例，默认值是 2。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:SurvivorRatio&lt;/font&gt;</code>设置<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;新生代&lt;/font&gt;</code>中<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;Eden&lt;/font&gt;</code>区与<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;Survivor&lt;/font&gt;</code>区的比例。<ol><li>默认 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;8:1:1&lt;/font&gt;</code>。</li></ol></li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:-UseAdaptivesSizePolicy&lt;/font&gt;</code>关闭自适应的内存分配策略。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-Xmn&lt;/font&gt;</code>设置<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;新生代&lt;/font&gt;</code>的空间大小。</li></ol><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><ol><li><strong>对象分配的一般过程</strong>，在对象被创建时一般都会在 Eden 区，S1 和 S2 区分别是（From 和 To）的标志（两个是可以发生身份交换的）。</li><li>当 Eden 区满的时候会发生一次 MinroGC，伴随着垃圾回收机制，Eden 区和 From 区都将发生垃圾回收。Eden 区幸存下来的将放入 To 区，From 区存活下来的也会被放入 To 中，此时 From 和 To 角色发生交换。To 区总是空的，From 区总是存在对象的。当一个对象的分代年龄达到 16 时将被复制到老年代中（很难再回收了）。</li><li>From-To 的角色交换就是<font style="color:#ED740C;">复制算法</font>，避免对象碎片化。</li><li>关于垃圾回收：<font style="color:#ED740C;">频繁收集新生代，很少在老年代收集，几乎不在永久代元空间收集</font>。</li></ol><p><img src="/mimi-blog/image/1725342889575-d53d3591-601c-4ec9-b37b-9f87132323ea.png"></p><ol start="5"><li><strong>对象分配的特殊过程</strong>，当新申请的对象发现在 Eden 区放不下了（进行一次 YGC），发生一次 YGC 还存不下就放入老年代，老年代还放不下就进行一次 FGC，当 FGC 后还是放不下去就报 OOM。期间有一次可以放入的就为对象分配内存空间。</li><li>当进行 YGC 中发现幸存者区还放不下（分代年龄到达阈值），就放入老年代，否则就放入幸存者区。</li><li>在 YGC 发生时可能会发生 FGC，但是在开发中通常的 FGC 发生在 YGC 之后，FGC 由 YGC 触发。</li><li>通常的年轻代、老年代、元空间波峰的展现结果是不一样的，例如 Eden 区的频率较高，波峰比较尖锐；老年代区则是跟台阶一样，一段时间触发一次。</li></ol><p><img src="/mimi-blog/image/1725344854562-6ddf17e1-3c4c-4b3c-88ac-64739ea87e22.png"></p><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><ol><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。<ol><li>新生代收集（Minor GC、Young GC），只是对新生代（Eden、S0、S1）进行收集。</li></ol></li></ol><p>:::color2<br>        1. 当年轻代空间不足时，触发 Minor GC，这里指的是 Eden 区，Survivor 区满了不会引发 GC（每次 GC 会清理年轻代的内存）。<br>        2. Minor GC 发生的比较频繁，因为大部分的对象都是在 Minor GC 中被收集。<br>        3. <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;Minor GC 会引发 STW&lt;/font&gt;</code>，暂停其它用户线程，等垃圾回收结束后用户线程才会恢复。</p><p>:::</p><pre><code class="hljs">2. 老年代收集（Major GC、Old GC），只是对老年代（Old）进行收集。</code></pre><p>:::color2<br>        1. 发生在老年代的 GC，对象从老年代消失时，也就是说 Major GC 或者 Full GC 发生了。<br>        2. 出现 Major GC 时 Minor GC 至少出现了一次（非绝对的，在 Parallel Scavenge 收集器的手机策略中就有直接进行 Major GC 的策略选择过程）<br>        3. Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长。<br>        4. 如果 Major GC 后，内存还是不足，就报<font style="color:#ED740C;"> OOM </font>了。</p><p>:::</p><pre><code class="hljs">3. 混合收集（Mixed GC），收集整个新生代以及部分老年代的垃圾收集（G1 GC 存在这种行为）。</code></pre><ol start="2"><li>整堆收集：收集整个 Java 堆和方法区的垃圾收集（Full GC）。</li><li>区分 Major GC 和 Full GC ，就在于是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;整堆收集&lt;/font&gt;</code>还是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;部分收集&lt;/font&gt;</code>。</li></ol><h3 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h3><ol><li>分代的唯一理由就是<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;优化 GC&lt;/font&gt;</code>。</li></ol><h3 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h3><ol><li>从内存模型的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，包含在 Eden 区域。</li><li>多线程同时分配时，使用 TLAB 可以避免一系列的线程安全问题。</li><li>TLAB 的空间进展 Eden 空间的 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;1%&lt;/font&gt;</code>，可以通过<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+UseTLAB&lt;/font&gt;</code>开启 TLAB，默认是开启的。</li><li>通过<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:TLABWasteTargetPercent&lt;/font&gt;</code>参数设置 TLAB 空间所占用 Eden 区域空间的百分比。</li><li>TLAB 分配失败后，JVM 就会尝试通过使用<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;加锁机制&lt;/font&gt;</code>避免共享对象的线程安全问题。</li></ol><h3 id="堆空间参数设置小结"><a href="#堆空间参数设置小结" class="headerlink" title="堆空间参数设置小结"></a>堆空间参数设置小结</h3><p>:::color5<br>-XX:+PrintFlagsInitial查看所有参数的默认值（JVM 参数）</p><p>-XX:+PrintFlagsFinal查看所有参数的最终只（存在修改，不再是初始值）</p><p>-Xms: 初始化堆空间内存（默认是物理内存的 1&#x2F;64）</p><p>-Xmx:最大堆内存（默认是物理内存的 1&#x2F;4）</p><p>-Xmn: 设置新生代的大小（初始值及最大值）</p><p>-XX:NewRatio：配置新生代与老年代在堆结构中的占比</p><p>-XX:SurvivorRatio:设置新生代 Eden 和 S0&#x2F;S1 空间的比例</p><p>-XX:MaxTenuringThreshold设置新生代垃圾的最大年龄</p><p>-XX:+PrintGCDetails输出详细的 GC 处理日志</p><p>-XX:+PrintGC  输出简要 GC 信息</p><p>-verbose:gc输出简要 GC 信息</p><p>-XX:HandlePromotionFailure是否设置空间分配担保</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则进行 Full GC。</p><p>:::</p><h3 id="堆是分配对象存储的唯一选择么？"><a href="#堆是分配对象存储的唯一选择么？" class="headerlink" title="堆是分配对象存储的唯一选择么？"></a>堆是分配对象存储的唯一选择么？</h3><ol><li>如果经过<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;逃逸分析&lt;/font&gt;</code>（Escape Analysis）后发现，一个对象并没有<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;逃逸&lt;/font&gt;</code>出方法的话，就可能被优化成在<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;栈上分配&lt;/font&gt;</code>。</li><li>如果一个对象在方法内部定义，如果这个对象只在方法内部使用，方法结束时对象也就没有被引用了，此时就是该对象没有逃逸，该对象就会在栈上分配。</li><li>如果一个对象在方法内部定义，通过参数传递或者对象返回，那么该对象就发生了逃逸，就会在堆中分配。</li><li>默认情况下开启了逃逸分析，<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+DoEscapenAnalysis&lt;/font&gt;</code>来设置逃逸分析是否开启。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;锁消除&lt;/font&gt;</code>，JIT 优化时会分析当前同步块是否只被一个线程使用，只被一个线程使用时进行锁消除。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;标量替换&lt;/font&gt;</code>：对象可能不需要作为一个连续的内存结构也可以访问到，那么对象可以不存储在主存中，而是存储在 CPU 的寄存器中。<ol><li>例如 Pointer (int x, int y)这样的对象，在经过分析可以标量替换时，将被替换为 int x, int y，最终将分配到栈中。</li><li><code>-XX:+EliminateAllocation</code>表示开启标量替换。</li></ol></li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ol><li>方法区是被所有线程所共享的，用于存储类的结构、特殊的方法（<init><clinit>），逻辑上是堆空间的一部分，但是一些简单的实现可能不会先则进行垃圾回收或者进行压缩。</li><li>Java8 中的元空间是方法区的落地与实现，同样的方法区可能会出现溢出等<code>java.lang.OutOfMemoryError:PermGen space/Metaspace</code>。</li><li>加载大量的 jar 包、tomcat 中部署过多的工程或者大量动态生成反射类会导致方法区的溢出。</li><li>元空间和永久代的区别就是：<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;元空间不在虚拟机设置的内存中，而是使用本地内存&lt;/font&gt;</code>。</li><li>方法区主要的垃圾回收有两种，分别为<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;常量池中废弃的常量以及不在使用的类型&lt;/font&gt;</code>。<ol><li>解析废弃常量和不再使用类型是需要花费时间的，所以说 Full GC 是比较耗时的。</li></ol></li></ol><h3 id="方法区相关参数"><a href="#方法区相关参数" class="headerlink" title="方法区相关参数"></a>方法区相关参数</h3><ol><li><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;-XX:PermSize&lt;/font&gt;</code>用来设置永久代初始分配空间，默认 20.75M。</li><li><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;-XX:MaxPermSize&lt;/font&gt;</code>用来<font style="color:#ED740C;"></font>设置永久代最大可分配空间，32 位机器上默认 64M，64 位机器上默认 82M。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:MetaspaceSize&lt;/font&gt;</code>替换掉了<code>-XX:PermSize</code>，默认是 21M。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:MaxMetaspaceSize&lt;/font&gt;</code>替换了<code>-XX:MaxPermSize</code>，默认是-1，无上限（不超出本地内存）。</li><li>在开发中一般不会设置最大元空间大小，一般会设置元空间的初始大小，在机器上默认 21M，如果元空间中超过了这个水位线，就会进行一次 Full GC，然后 MetaspaceSize 将被重置。重置的大小依据 Full GC 释放了多少元空间，如果释放的元空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高 MetaspaceSize，如果释放空间过多，就会适当降低 MetaspaceSize。</li><li>因为每次调整就会进行一次 Full GC，因此在开发中应适当调整 MetaspaceSize 的值。</li></ol><h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><ol><li><strong>类型信息：</strong><ol><li>类型的完整有效名称（全限定类名）。</li><li>类型直接父类的完整有效名（对于 interface 或者 java.lang.Object，都没有父类）。</li><li>类型的修饰符（public、abstract、final 的某个子集）。</li><li>类型实现接口的一个有序序列（class Cat implement A, B, C）。</li></ol></li><li><strong>域（Field）信息：</strong><ol><li>域名称、域类型、域类型、域修饰符。</li></ol></li><li><strong>方法（Method）信息：</strong><ol><li>方法名称、方法返回类型、方法参数的数量和类型、方法修饰符、方法字节码、操作数栈、局部变量表大小、异常表。</li></ol></li><li><strong>运行时常量池：</strong><ol><li>常量池的概念，当一个类通过类加载生成的字节码时会在其中指定一个 Constant_Pool 这样的信息，其中使用符号的形式声明了对应的类或者其他信息。</li></ol></li></ol><p><img src="/mimi-blog/image/1725438672122-6b623eae-bd9c-4fb4-b1bb-ef0308dfd433.png"></p><pre><code class="hljs">2. 运行时常量池则表示的是，在程序运行时将一些字面量存放在常量池中。</code></pre><p><img src="/mimi-blog/image/1725439939768-bcf613aa-faad-439f-bac4-382a1a0c4576.png"></p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><ol><li>判断一个类型是否属于“不再被使用的类”，这是比较苛刻的，需要满足以下三个条件。<ol><li>该类所有的实例都被回收，也就是 Java 堆中不存在该类型以及任何其子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件通常是很难达成的。</li><li>该类对应的 Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol></li></ol><p><img src="/mimi-blog/image/1725442161225-a2f786ba-c18b-4648-9cff-7477c3e809df.png"></p><h1 id="本地方法库"><a href="#本地方法库" class="headerlink" title="本地方法库"></a>本地方法库</h1><ol><li>一个 Native Method 方法就是一个 Java 调用非 Java 代码的接口，一个 Native Method 是由 C 或者 C++实现的。为了使得 Java 与 C&#x2F;C++柔和在一起。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>native 方法不可以被 abstract 关键字修饰，因为此方法已经被 C&#x2F;C++实现了。</li><li>Native Method 的诞生是为了 Java 与 Java 外层的交互、与操作系统的交互等（开放国家 与 闭门锁国）。</li></ol><h1 id="对象实例化、内存布局、访问定位"><a href="#对象实例化、内存布局、访问定位" class="headerlink" title="对象实例化、内存布局、访问定位"></a>对象实例化、内存布局、访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ol><li>创建对象的步骤<ol><li>判断对象对应的类是否加载、链接、初始化。现去 Metaspace 中的常量池中定位一个类的符号引用，且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果不存在，则会在双亲委派模式下，使用当前以 ClassLoader+包名+类名为 key 进行查找对应的.class 文件，如果没有文件就会报<code>ClassNotFoundException</code>异常，如果找到了就进行类加载，且生成对应的 Class 类对象。</li><li>为对象分配内存（计算占用大小，然后在堆中划分一块儿内存给新对象，如果实例成员变量是引用变量，进分配引用变量空间即可（4 字节））。<ol><li>在堆内划分时，首先检查堆中是否规整，如果规整的就进行<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;指针碰撞&lt;/font&gt;</code>；如果不规整时，就会维护一个列表，记录内存块儿的可用空间，从列表中找到一个空间来存放。</li></ol></li><li>处理并发安全问题，使用 CAS 、区域加锁保证更新原子性或者（TLAB<code>-XX:+UseTLAB</code>）。</li><li>初始化分配到的空间，为所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用（赋默认值）。</li><li>设置对象的对象头。</li><li>执行 init 方法进行初始化（显示赋默认值）。</li></ol></li></ol><table><thead><tr><th>方式</th><th>字节码</th></tr></thead><tbody><tr><td>new</td><td>new   dum  invokespecial</td></tr><tr><td>Class 的 newInstance()</td><td></td></tr><tr><td>Constructor 的 newInstance(Xxx)</td><td></td></tr><tr><td>Clone</td><td></td></tr><tr><td>反序列化</td><td></td></tr><tr><td>第三方库 Objenesis</td><td></td></tr></tbody></table><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/mimi-blog/image/1727658212370-ffbb52af-a23d-472a-8383-845b74d813cb.jpeg" alt="画板"></p><p><img src="/mimi-blog/image/1725445415991-b55aadde-26f9-4071-a9ff-ca916b57b370.png"></p><h2 id="访问定位"><a href="#访问定位" class="headerlink" title="访问定位"></a>访问定位</h2><ol><li>通过栈上访问的方式就可以访问到对象实例。</li><li>句柄访问：在堆内存中有一块区域（句柄池），句柄池中记录了<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;对象实例数据的指针以及对象元数据地址&lt;/font&gt;</code>。</li><li>直接访问：通过记录地址直接访问对象实例以及对象元数据信息（Hotspot 采用）。</li></ol><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><ol><li>虚拟机的执行引擎是由软件自行实现的，不受物理条件的约束限制指令级与执行引擎的结构体系，<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;能够执行不被硬件直接支持的指令级&lt;/font&gt;</code>。</li></ol><p><img src="/mimi-blog/image/1725447177380-79ab28c4-23ac-4e97-9db4-70658d6415a6.png"></p><p><img src="/mimi-blog/image/1725448099238-aebc2d51-617e-4082-9b7a-c65ff56c476c.png"></p><ol start="2"><li>解释的过程：当 Java 虚拟机启动时会根据预定义规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>编译的过程：虚拟机将源代码直接编译成和本地机器平台相关的指令执行。</li></ol><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><ol><li>解释器就是 Java 能够跨平台的重要部分，JVM 读入 Java 字节码文件，通过不同平台 JVM 虚拟机来更好的翻译成对应机器的机器指令进行执行。</li></ol><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ol><li>热点代码探测：一次被多次调用的方法或者一个方法体内部循环次数较多的循环体都可以称之为<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;热点代码&lt;/font&gt;</code>。通过 JIT 编译器编译为本地机器指令，由于编译方式发生在方法的执行过程中，因此被称为<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;栈上替换&lt;/font&gt;</code>或简称为<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;OSR(On Stack Replacement)编译&lt;/font&gt;</code>。</li><li>一个方法被调用了多少次？一个循环需要达到多少循环次数？才能够被编译器直接编译，这主要依靠<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;热点探测功能&lt;/font&gt;</code>。</li><li>在 Client 上默认是<code>1500</code>次、Server 上默认是<code>10000</code>次，这是对方法调用的热点探测阈值。</li><li>热度衰减，判断阈值不是绝对的，只是在一定频率上进行检测，如果一段时间内达不到阈值则方法调度计数器<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;热度衰减&lt;/font&gt;</code>，而这段时间成为此方法统计的<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;半衰周期&lt;/font&gt;</code>。</li><li>热度衰减的动作在虚拟机进行垃圾回收时顺便进行的，可以通过<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:-UserCounterDecay&lt;/font&gt;</code>来关闭热度衰减，可以使用<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:CounterHalfLifeTime&lt;/font&gt;</code>参数设置半衰周期的时间（单位：秒）。</li><li>JVM 的执行方式：<ol><li><code>java -Xint -version</code>、<code>java -Xcomp -version</code>、<code>java -Xmixed -version</code>， 可以切换。</li></ol></li></ol><h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><ol><li>String 在 JDK9 之后做了一些变更，9 之前 value 使用的是 char 数组，9 之后使用的是 byte 数组。</li><li>UTF-16 的编码一般的一个字符占用两个字节，但在常见的 latin1 编码就足够了，这样就会出现空间浪费的情况，所以将 char 字符数组替换为了 byte 数组。但是一个字符需要两个字节去存储的可以通过字符编码指定来改变。</li><li>字符串常量池中是不会存储相同的字符串字面量的，相当于 Java 中的 Set 集合。</li><li>StringPool 在底层是一个固定的 Hashtable，默认大小长度是 1009，在 JDK7 时 Hashtable 大小改为 60013，这是为了降低 hash 冲突概率，当 hash 冲突造成的链表过长时会降低性能。</li><li>在 JDK8 时设置 StringTableSize 时最小值为 1009<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:StringTableSize=[size]&lt;/font&gt;</code>。</li><li>StringTable 存在垃圾回收，如果内存中大量的创建 string 字符串时，使用 intern 可以降低内存大小。</li></ol><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ol><li>常量池是 Java 系统级别提供的缓存池，提供在 Java 堆中。</li><li>字符串放入 Java 常量池中的两种方式：直接使用双引号声明，调用 intern 方法将字符串放入缓冲池。</li></ol><p><img src="/mimi-blog/image/1725517999296-bd57dd0b-98a4-40ea-81f0-b964e4f98a4a.png"></p><h2 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h2><ol><li>常量和常量拼接结果还是在常量池中，原理是编译器优化。</li><li>常量池中常量是唯一的。</li><li>只要其中一个是变量，结果就在堆中，变量拼接原理是 StringBuilder。</li><li>如果拼接的结果调用 intern 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。</li></ol><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><ol><li>用到拼接的第一条，常量和常量之间拼接放入常量池中。通过 idea 反编译的结果 a 和 b 都是”abc”，通过字节码的角度分析（ldc #2 &lt;’abc’&gt;  istroe_1  ldc #2 &lt;’abc’&gt; istroe_2）都是从常量池中取出来的 abc 分别给 ab 使用。所以最终返回了 true，内存地址一致。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>a == b ? <br></code></pre></td></tr></table></figure><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><ol><li>用到拼接第二条，如果拼接时出现变量，则放入堆空间中（new String()），intern 方法相当于将 new Stirng()中的 value 指向常量池的地址做返回。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;因此在字符串拼接中需要使用 StringBuilder 或者 StringBuffer 来拼接，使用+拼接会不断创建 StringBuilder 对象，直接使用 StringBuilder 则只有一个。&lt;/font&gt;</code></li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;实际开发中如果可以大概确定字符串拼接的长度结果，建议使用 StringBuilder(int)构造器，直接创建对应 capacity 大小的数组，避免过多的扩容操作。&lt;/font&gt;</code></li></ol><p><img src="/mimi-blog/image/1725519856319-345e2bf0-f1ac-4eae-8920-75723827a76a.png">对应字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 小猫儿老板</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2024-9-5 14:57</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + b;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> a + <span class="hljs-string">&quot;b&quot;</span>;<br><br>        <span class="hljs-comment">// c 取常量池地址  而 a1 是在堆中</span><br>        <span class="hljs-comment">// 底层new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() false</span><br>        System.out.println(c == a1);<br><br>        <span class="hljs-comment">// 和上面原理一样  new StringBuilder() 最终还是new String() 所以两个是不同的对象 false</span><br>        System.out.println(a1 == b1);<br><br>        <span class="hljs-comment">// 常量拼接  在常量池中找  true</span><br>        System.out.println(c == d);<br><br>        <span class="hljs-comment">// true  将拼接结果放入常量池中，并返回常量池地址。如果发现常量池有这个值就直接返回地址</span><br>        System.out.println(a1.intern() == b1.intern());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern 方法"></a>intern 方法</h2><ol><li>intern 返回字符串对象的规范表示形式。字符串池最初为空，由String类私有地维护。当调用intern方法时，如果池中已经包含一个由equals(object)方法确定的与此string对象相等的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对该String对象的引用。</li><li>由此可见，对于任意两个字符串s和t, s. intern() &#x3D;&#x3D; t. intern()当且仅当s. equals(t)为真时为真。</li><li>以下一段代码创建了 6 个对象，主要依据字节码指令来判断。<ol><li>new StringBuilder()</li><li>new String(), ldc <a></li><li>new String() , ldc <b></li><li>StringBuilder.toString()还会帮我们 new String()</li><li>所以最终是 6 个对象，堆中创建了（StringBuilder、String、String、String），常量池中创建了<a>和<b>;</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/StringBuilder&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br> <span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">10</span> dup<br><span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">22</span> dup<br><span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<br><span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">34</span> astore_1<br><span class="hljs-number">35</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>以下代码在各个版本中运行结果是不一样的，这是因为在个版本中对<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;常量池迁移&lt;/font&gt;</code>所导致的。</li><li>在 JDK6 中常量池在堆中，a 对象创建后在常量池中创建了”1“，在对中创建了”11“，此时在堆中的是不会写入到常量池中的，所以常量池只有 1，届时进行比较就是两个不同的对象了。</li><li>在 JDK7&#x2F;8 中常量池被迁移到了方法区中（元空间、永久代），Java 认为都在堆中，a.intern 执行时检查常量池中没有”11”，索性就将常量池中的引用指向了堆中的”11”（存在两份”1”，认为这是没必要的，所以就在常量池中直接指向堆中的”11”），所以在 JDK7&#x2F;8 中是 true 的。</li><li>在 JDK11 中这段代码结果又变成了 false，是因为常量池又被迁移了回去么，结果是不是的。<ol><li>JDK11 中的一个枚举类 Source，先一步在常量池中创建了”11”，所以结果返回了 false。</li></ol></li><li>如果这段代码的 4 和 5 行交换结果就为 false 了，这是因为 a 创建在堆还没有将常量池的数据指向堆，b 就在常量池中创建了”11”，此时两个地址不一样所以返回了 false。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringClazz</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        a.intern();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<br>        System.out.println(a == b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ol><li>Java 对内存的管理是自动的，不需要开发人员手动 remove，从而降低了内存泄漏的风险。</li><li>判断对象存活一般有两种方式：<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;引用计数算法&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;可达性分析算法&lt;/font&gt;</code>。<ol><li><strong>引用计数算法：</strong>每个对象保存一个<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;整型的引用计数器属性，用于记录对象被引用的情况&lt;/font&gt;</code>，如果一个对象计数器为 0 就表示没有人引用它，就会被垃圾回收掉。缺点：增加了空间的开销、增加了时间开销、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;无法处理循环引用的场景&lt;/font&gt;</code>。当对象之间产生循环引用时，这几个对象将无法被回收，从而产生<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;内存泄漏&lt;/font&gt;</code>的问题。这也是 Java 没有采用这一方法的原因。</li></ol></li></ol><p><img src="/mimi-blog/image/1725526453830-63ae2e4c-65fc-42a2-9122-ed4eefe45a0f.png"></p><pre><code class="hljs">2. **可达性分析算法（根搜索算法）**：可以解决循环引用的问题。    1. GC Roots 可以是那些具体元素？        1. 虚拟机栈中引用的对象        2. 本地方法栈        3. 方法区中静态属性引用的对象        4. 常量池的引用        5. 被同步锁 synchronized 持有的对象        6. Java 虚拟机内部引用        7. 反应 Java 虚拟机内部情况的 JMXBean、JVMTI 等。</code></pre><p><img src="/mimi-blog/image/1725527086714-abd630d2-0c22-467a-8d05-4ee70ebc1281.png"></p><h2 id="对象的-finalizetion-机制"><a href="#对象的-finalizetion-机制" class="headerlink" title="对象的 finalizetion 机制"></a>对象的 finalizetion 机制</h2><ol><li>对象提供了 finalize 方法，在对象被回收之前将调 finalize 方法。</li><li>如果从所有根节点都访问不到该节点时，那么就认为当前对象要被回收了，回收之前会调用 finalize 方法，finalize 方法手动调用是没效果的，需要 GC 后进行调用。</li><li>虚拟机对一个对象定义的三种状态：<ol><li>可触及的：从某个根根节点可以访问到当前对象，表示还存在引用关系。</li><li>可复活的：从某个根节点不可以访问到当前对象，在进行 finalize 方法调用时，又重新被引用，那么认为此次的垃圾回收是不合理的。</li><li>不可触及的：对象的 finalize 方法被调用，且没有被复活，那么就会进入不可触及的状态，就再也不可能有复活的可能了，因为 finalize 方法只可能被调用一次。</li></ol></li><li>finalize 方法的时候可以直接的影响 GC 的效率，如果重写的 finalize 方法中出现了程序的不合理设计可能导致 GC 时间过长，出现 STW 的严重情况。</li></ol><h2 id="对象回收的具体过程"><a href="#对象回收的具体过程" class="headerlink" title="对象回收的具体过程"></a>对象回收的具体过程</h2><ol><li>判定一个 obj 是否可回收，需要经过两次标记过程，分别是：<ol><li>对象 obj 到 GC Roots 之间没有引用链，则进行一次标记。</li><li>判断 finalize 方法是否有执行的必要。<ol><li>如果 finalize 方法没有被重写或 finalize 方法已经被虚拟机调用过了，则虚拟机认为没有执行必要了，最终判定 obj 为不可触及状态。</li><li>如果对象 obj 重写了 finalize 方法，且还未执行过，obj 会被插入到F-Queue 队列中，一个由虚拟机自动创建的 Finalizer 线程触发其 finalize 方法执行。</li><li>finalize 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 obj 在 finalize 中与引用链上的任何一个对象发生引用关，那么在下次标记时 obj 会被移除<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;”回收“集合&lt;/font&gt;</code>。之后对象再次出现没有引用存在的情况，finalize 方法不会被再次调用，对象会直接变为不可触及状态。</li></ol></li></ol></li><li>以下代码为对象复活过程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 小猫儿老板</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2024-9-5 17:45</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FinalizerTest obj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        obj = <span class="hljs-built_in">this</span>;<br>        System.out.println(<span class="hljs-string">&quot;FinalizerTest finalized&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizerTest</span>();<br>        obj = <span class="hljs-literal">null</span>;<br>        System.out.println(<span class="hljs-string">&quot;进行第一次GC&quot;</span>);<br>        System.gc();<br>        <span class="hljs-comment">// 等待 Finalizer 线程执行 finalize</span><br>        <span class="hljs-keyword">try</span>&#123;TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;<br>        <br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dea&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is survival&quot;</span>);<br>        &#125;<br>        <br>        System.out.println(<span class="hljs-string">&quot;进行第二次GC&quot;</span>);<br>        obj = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <br>        <span class="hljs-keyword">try</span>&#123;TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;<br>        <br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dea&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is survival&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>进行第一次GC<br>FinalizerTest finalized<br>obj is survival<br>进行第二次GC<br>obj is dea<br></code></pre></td></tr></table></figure><h2 id="清除算法"><a href="#清除算法" class="headerlink" title="清除算法"></a>清除算法</h2><ol><li>较为常见的三种垃圾收集算法，<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;标记 -清除算法&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;复制算法&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;标记-压缩算法&lt;/font&gt;</code>。</li></ol><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><ol><li>当堆中有效内存空间被耗尽时，会停止整个程序（STW），然后标记和清除工作。</li><li>标记：从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象（非垃圾对象）。</li><li>清除：对堆内存从头到尾进行线性遍历，如果发现某个对象在其 Header 中没有标记可达对象，就将其回收（将清除对象的地址放入空闲列表中）。</li><li>优缺点：<ol><li>优点：算法容易理解。</li><li>缺点：效率较低（两次遍历），进行 GC 时需要停止整个用户程序（STW），用户体验差。清除后的内存是不连续的（内存碎片），再次分配对象时就会在空闲列表中检查，那个空间足够放下对象占据的内存就被放入。</li></ol></li></ol><p><img src="/mimi-blog/image/1725534928065-72c25e0b-c224-4f8d-af3b-df7b1fe2eadd.png"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ol><li>当需要进行对象清除时从 ROOT 节点遍历，可达对象直接复制到新表中，赋值完毕后将原来的表做销毁，新表则作保留。</li><li>优缺点：<ol><li>优点：运行高效（没有标记），内存中不存在碎片（指针碰撞）。</li><li>缺点：占用空间，需要新开辟一个一模一样的内存空间。G1 分拆为大量的 region 的 GC，赋值而不是移动，所以当转移对象时栈中的引用也需要跟着维护，成本开销很大。</li></ol></li><li>复制算法通常的处理垃圾不是很多，对象占用不是太大才可以。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;在幸存者区中使用的就是复制算法&lt;/font&gt;</code>。</li></ol><p><img src="/mimi-blog/image/1725535485284-5d0415ad-1a9f-4aca-9d1b-8e7646af5621.png"></p><h3 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h3><ol><li>第一阶段和<code>标记-清除算法</code>一样，从根节点开始递归遍历进行标记。第二阶段将所有的存活对象压缩到内存的一段，按照顺序排放。之后对外界进行清除。</li><li>优缺点：<ol><li>优点：解决了标记清除和复制算法的缺点。</li><li>缺点：效率低于复制算法，移动对象时如果对象被其他对象引用，则还需要调整引用的地址，移动过程中需要停止用户应用程序。</li></ol></li></ol><p><img src="/mimi-blog/image/1725536355847-c040c0ca-bb0e-47f0-97f7-d539f4f8ed43.png"></p><h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><ol><li>效率上来说复制算法最好，但是占用较大的内存空间。</li></ol><table><thead><tr><th></th><th>标记清除算法</th><th>复制算法</th><th>标记压缩算法</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最快</td><td>最慢</td></tr><tr><td>空间开销</td><td>少（但会积累内存碎片）</td><td>大（开辟两倍空间）</td><td>少</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><ol start="2"><li>没有最优的算法，只有最适合的算法。</li></ol><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ol><li>年轻代：年轻代中的对象都是朝生夕死的，这就符合复制算法来进行收集，而且复制算法的效率是很高的，而且年轻代的区域比较小，对空间的浪费也是较小的。</li><li>老年代：老年代中的对象都是比较难回收的，存活率高，回收不频繁。这也就不适合复制算法来进行收集，相对应的标记清除算法和标记压缩算法就恰好适用，Hotspot 虚拟机使用CMS 垃圾回收器对老年代进行垃圾的收集，首先使用的就是标记清除算法，出现空间碎片了就是用标记压缩进行收尾工作。</li></ol><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><ol><li>如果等待垃圾满的时候再回收，这样用户线程就会被挂起很长时间，如果频繁执行就会严重影响用户的体验或者系统的稳定性，因此诞生了<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;增量收集算法&lt;/font&gt;</code>。增量收集算法是每个一段时间对空间中的垃圾进行清除，在一定意义上使得用户线程合 GC 线程交替执行，从而达到用户线程无感知的目的。增量算法实际上用的还是标记清除算法。</li><li>缺点：在垃圾回收过程中，间断性的执行了应用程序代码，这样会减少系统停顿的时间，但是会出现线程之间频繁的上下文切换，使得垃圾回收总体成本上升，造成<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;吞吐量&lt;/font&gt;</code>下降。</li></ol><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><h2 id="相关概念描述"><a href="#相关概念描述" class="headerlink" title="相关概念描述"></a>相关概念描述</h2><h3 id="system-gc"><a href="#system-gc" class="headerlink" title="system.gc"></a>system.gc</h3><ol><li><code>System.gc()</code>用户级别调用的 Full GC，但是 System.gc()附加了一条免责声明，当调用 System.gc()时不一定百分百进行。</li><li><code>System.runFinalization()</code>方法保证每次调用时调用回收对象的 finalize 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemGC</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SystemGC</span> <span class="hljs-variable">systemGC1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemGC</span>();<br>        systemGC1.gc5();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// [GC (System.gc()) [PSYoungGen: 15516K-&gt;10736K(76288K)] 15516K-&gt;10992K(251392K), 0.0043823 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 256K-&gt;10865K(175104K)] 10992K-&gt;10865K(251392K), [Metaspace: 3284K-&gt;3284K(1056768K)], 0.0041533 secs]</span><br>        <span class="hljs-comment">// 被放入老年代 没有被FGC回收</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        bytes = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// [GC (System.gc()) [PSYoungGen: 15516K-&gt;776K(76288K)] 15516K-&gt;784K(251392K), 0.0005587 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;624K(175104K)] 784K-&gt;624K(251392K), [Metaspace: 3278K-&gt;3278K(1056768K)],</span><br>        <span class="hljs-comment">// 在YGC中就被回收</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc3</span><span class="hljs-params">()</span> &#123;<br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<br>        <span class="hljs-comment">// [GC (System.gc()) [PSYoungGen: 15516K-&gt;10736K(76288K)] 15516K-&gt;10992K(251392K), 0.0043192 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 256K-&gt;10865K(175104K)] 10992K-&gt;10865K(251392K), [Metaspace: 3284K-&gt;3284K(1056768K)]</span><br>        <span class="hljs-comment">// 因为本地变量表中还存在对 bytes 的引用 没有被后续变量所占用所以没有被回收</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc4</span><span class="hljs-params">()</span> &#123;<br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// [GC (System.gc()) [PSYoungGen: 15516K-&gt;840K(76288K)] 15516K-&gt;848K(251392K), 0.0007088 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;623K(175104K)] 848K-&gt;623K(251392K), [Metaspace: 3271K-&gt;3271K(1056768K)]</span><br>        <span class="hljs-comment">// 在YGC时被回收，本地变量表中bytes的位置被value占用  没有任何指向  所以被回收</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc5</span><span class="hljs-params">()</span> &#123;<br>        gc1();<br>        <span class="hljs-comment">// [GC (System.gc()) [PSYoungGen: 15516K-&gt;10728K(76288K)] 15516K-&gt;10976K(251392K), 0.0042957 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 248K-&gt;10865K(175104K)] 10976K-&gt;10865K(251392K), [Metaspace: 3298K-&gt;3298K(1056768K)], 0.0041734 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[GC (System.gc()) [PSYoungGen: 1310K-&gt;32K(76288K)] 12176K-&gt;10897K(251392K), 0.0002109 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>        <span class="hljs-comment">//[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(76288K)] [ParOldGen: 10865K-&gt;625K(175104K)] 10897K-&gt;625K(251392K), [Metaspace: 3303K-&gt;3303K(1056768K)]</span><br>        <span class="hljs-comment">// 在gc1中bytes未被回收  在当前方法中将其回收</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存溢出、内存泄漏"><a href="#内存溢出、内存泄漏" class="headerlink" title="内存溢出、内存泄漏"></a>内存溢出、内存泄漏</h3><ol><li>内存溢出通常的出现在栈中以及元空间中，通常的内存中对象的产出的数量要大于垃圾回收器回收的数量，早晚会出现内存溢出情况。</li><li>Stack Over Flower 异常信息表示栈溢出，往往程序编写不规范导致，也可能栈大小设置的不好导致的。</li><li>内存溢出出现前往往会伴随着一个 FGC。</li><li>Java 中创建了一个非常大的对象，超出了堆的容量，就不会触发 FGC 直接爆出内存溢出异常。</li></ol><hr><ol start="5"><li>内存泄漏在 Java 层面上来说内存中有内存被对象占用，但是 GC 又回收不掉，这样就会出现内存泄漏的问题（类似于循环依赖，Java 中使用的是可达性分析算法，所以没有循环依赖导致的内存泄露问题）。</li><li>当一个单例对象持有对其他对象引用时，该对象将无法被回收，因为单例对象的生命周期往往需要伴随着程序的结束而结束。</li><li>当大量的资源链接没有及时的 close 时也会出现内存泄漏的问题。</li><li>例如下图，当一个对象在引用链上被断开时另一个还存在指向，就会导致下下面一片的对象无法被回收掉，从而导致内存泄漏的问题。</li></ol><p></p><p><img src="/mimi-blog/image/1725601736713-889f94d0-6c21-4100-9af9-5546bc497a77.png"></p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><ol><li>由于 GC 线程的开启导致用户线程暂时挂起，这在所有垃圾回收器中都是常见的。</li></ol><h3 id="安全点、安全区域"><a href="#安全点、安全区域" class="headerlink" title="安全点、安全区域"></a>安全点、安全区域</h3><ol><li>GC 并不是随时随地执行的，是根据对程序划分的安全点或者安全区域执行的。</li><li>举例：相当于一个货车司机在高速跑长途，在这段路上分别有多个服务区，那么这个服务区就是安全点，司机到达服务区后可以方便（对垃圾进行回收），然后在启动货车（用户线程）继续跑。安全区域就是在一段路程上有一段需要走高速一段则需要走民间小路，当走民间小路时就没有那么多规矩，想方便时随时停下来就可以进行（垃圾回收），这可以叫做安全区域。</li></ol><p><img src="/mimi-blog/image/1725602963362-954060df-8769-43d5-bc21-6e27e90b3ff9.png"></p><h3 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h3><ol><li>强引用：直接 new 出来的对象为强引用，垃圾收集器永远不会回收掉这些对象。</li><li>软引用：在系统将要发生内存溢出前，将把软引用对象列入回收范围中进行二次回收，如果此次回收后还没有解决内存溢出的问题则溢出。</li><li>弱引用：被弱引用关联的对象只剩存到下一个垃圾收集之前，当垃圾收集器收集时，无论空间是否足够都将进行回收。</li><li>虚引用：完全不会对其生存时间构成影响，无法通过虚引用来获得一个对象的实例，唯一目的就是在这个对象被收集器回收前收到一个系统通知。</li><li>强弱软虚引用都是在对象在引用链上的情况。</li></ol><hr><p><strong>强引用</strong></p><p>强引用是可达对象，只有没有最想指向它时垃圾收集器才会回收它，强引用也是造成内存溢出的主要原因之一。</p><p><strong>软引用</strong></p><p>内存不足即回收。主要在有用但不是必须的对象身上。内存溢出于非强引用无关系，因为在内存溢出时非强引用就会被回收。</p><p><strong>弱引用</strong></p><p>不管内存够不够，只要 GC 触发就会回收弱引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QRRXTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Stu</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stu</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jock&quot;</span>);<br>        SoftReference&lt;Object&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(o);<br>        o = <span class="hljs-literal">null</span>;<br>        System.out.println(<span class="hljs-string">&quot;gc begin : &quot;</span> + obj.get());<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">try</span>&#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;<br>            System.gc();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">// oom 时 对象被回收    当是Weak时第一次GC时就已经是null了</span><br>            System.out.println(<span class="hljs-string">&quot;gc after : &quot;</span> + obj.get());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stu</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stu&#123;&quot;</span> +<br>        <span class="hljs-string">&quot;age=&quot;</span> + age +<br>        <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><ol><li>吞吐量：运行用户代码的时间占总运行时间的比例。</li><li>暂停的时间：执行垃圾收集时，程序在工作线程被暂停的时间。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率（频率低的时候不一定回收的时间短，频率高的时候时间可能短一点）。</li><li>内存占用：Java 堆区占用内存的大小。</li><li>快速：一个对象诞生到被回收所经历的时间。</li><li>吞吐量和暂停时间在 GC 设计上一个为高吞吐和低延迟。<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;在吞吐量优先的情况下，降低暂停时间&lt;/font&gt;</code>。</li></ol><h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><ol><li>1999 年 JDK1.3.1 出现了串行方式的 Serial GC，也是第一款 GC，ParNew 是 Serial GC 的多线程版本。</li><li>2002 年 ，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 发布。</li><li>Parallel GC 在 JDK6 之后为 HotSpot 的默认 GC。</li><li>2012 年，JDK1.7u4 中 G1 可用。</li><li>2017 年，JDK9 中 G1 变为默认的 GC，以替换 CMS。</li><li>2018 年，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年，JDK11 发布，引入 Epsilon 垃圾回收器，被称为 No-Op（无操作）。</li><li>2019 年，JDK12 发布，增强 G1，自动返回未用堆内存给操作系统，同时引入 Shenandoah GC 低停顿时间的 GC。</li><li>2020 年，JDK14 发布，删除 CMS 垃圾回收器，扩展 ZGC 在 macOS 和 windows 上应用。</li></ol><hr><ol start="10"><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel、Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li></ol><hr><p><img src="/mimi-blog/image/1725609662187-4e03da08-6e48-482a-90f2-fbefc624a704.png"></p><h2 id="检查当前版本使用-GC-的情况"><a href="#检查当前版本使用-GC-的情况" class="headerlink" title="检查当前版本使用 GC 的情况"></a>检查当前版本使用 GC 的情况</h2><ol><li><code>jps | jinfo -flag UseParallelGC [pid]</code>。</li><li><code>-XX:+PrintCommandLineFlags</code>，运行时打印命令行标记信息。</li></ol><h2 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h2><ol><li>Serial 使用的是复制算法，串行回收和“STW”机制的方式执行内存回收。</li><li>Serial Old 收集器同样是串行回收和“STW”机制的方式执行内存回收，使用的是标记压缩算法。</li><li>优势：简单高效，限定在单个 CPU 环境来说，Serial 收集器由于没有线程交互的开销，可以专心做垃圾收集。</li></ol><p><img src="/mimi-blog/image/1725610783248-d274b01c-56f9-4bb0-9a8d-7bd9a95d4e90.png"></p><ol start="4"><li>在开发中通过<code>-XX:+UseSerialGC</code>参数开启使用 SerialGC。效果就是新生代和老年代支持 SerialGC 和 SerialGC Old。</li></ol><h2 id="ParNew-GC"><a href="#ParNew-GC" class="headerlink" title="ParNew GC"></a>ParNew GC</h2><ol><li>ParNew GC 采用并行回收，使用的也是复制算法，也使用了 STW 机制。</li></ol><p><img src="/mimi-blog/image/1725610752956-7e842a69-7029-4042-8fe7-7437ffb06523.png"></p><ol start="2"><li><code>-XX:UseParNewGC</code>使用 ParNewGC 回收器，不太常用了解即可。</li></ol><h2 id="Parallel-Scavenge-GC"><a href="#Parallel-Scavenge-GC" class="headerlink" title="Parallel Scavenge GC"></a>Parallel Scavenge GC</h2><ol><li>Parallel Scavenge GC 使用的也是复制算法和 STW 机制。</li><li>Parallel Scavenge GC 会根据运行的情况动态调整内存的情况，以达到最优的策略，<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;可控制的吞吐量&lt;/font&gt;</code>。</li><li>这是 Java8 默认使用的 GC。</li><li>-XX:MaxGCPauseMillis 和-XX:GCTieRatio 是互相矛盾的，所以在设置上需要慎重。</li><li>参数设置：<ol><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+UseParallelGC&lt;/font&gt;</code>、<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+UseParallelOldGC&lt;/font&gt;</code>，存在互相激活的特性，成对出现。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:ParallelGCThreads&lt;/font&gt;</code>设置年轻代并行收集器的线程数，线程数多垃圾回收的越快，但是切换线程任务时会消耗性能，设置为 CPU 核数。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+MaxGCPauseMillis&lt;/font&gt;</code>设置垃圾收集器最大停顿时间。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+GCTieRatio&lt;/font&gt;</code>垃圾收集时间占总时间的比例（1 &#x2F; (N+1)）用于平衡吞吐量的大小。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+UseAdaptiveSizePolicy&lt;/font&gt;</code>自适应调节策略。</li></ol></li></ol><h2 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h2><ol><li>CMS 是并发收集器，收集线程和用户线程并发去工作。</li><li>CMS 的垃圾回收算法是标记-清除算法，也会有 STW，但是会降低 STW 的时间。</li></ol><p><img src="/mimi-blog/image/1725612030429-0c65b7a8-6c92-4a1a-a14a-cae920f692cc.png"></p><ol start="3"><li>在运行初期 CMS 会进行对象的初始标记，这一操作是 STW 的，需要停掉用户线程。在后续运行中进行与用户线程的并发标记，因为这一时间是并行的所以在并发标记后进行一次 STW 的重新标记，然后进行并发清理。</li><li>CMS 优缺点：<ol><li>优点：并发收集、低延迟。</li><li>缺点：<ol><li>会产生内存碎片（因为是并发的所以不可以使用标记-压缩算法），在无法匹配大对象时进行一次 FGC。</li><li>CMS 收集器对 CPU 资源非常敏感，并发阶段虽然不会导致用户停顿，但是占用了一些线程导致用户线程变慢。</li><li>CMS 收集器无法处理浮动垃圾，在并发标记阶段某些对象变为垃圾，在进行重新标记时食不包含这些对象的，所以在清理阶段不会注意到这些对象。</li></ol></li></ol></li><li>参数设置：<ol><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/font&gt;</code>手动指定使用 GC。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:CMSInitatingOccupanyFraction&lt;/font&gt;</code>设置堆内存使用率的阈值，当程序中对象回收缓慢就设置的相对大一些，这样可以降低 CMS 回收的频率。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:UseCMSCompactAtFullCollection&lt;/font&gt;</code>指定执行完 Full GC 后对内存空间进行整理。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:CMSFullGCsBeforeCompaction&lt;/font&gt;</code>执行多少次 Full GC 后对内存进行整理。</li><li><code>&lt;font style=&quot;color:#ED740C;&quot;&gt;-XX:ParallelCMSThreads&lt;/font&gt;</code>设置 CMS 的线程数量，和用户线程并发的 CMS 线程。</li></ol></li></ol><h2 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h2><ol><li>并发与并行：<ol><li>并行性：G1 在回收对象时可以存在多个线程同时工作，效力于多核计算机（STW）。</li><li>并发性：拥有和应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会再整个回收阶段完全阻塞应用程序的情况。</li></ol></li><li>分代收集：<ol><li>属于分代型的垃圾回收器，将内存分为多个 Region，使用 Region 来表示 Eden、Survivor、Old、大对象。</li></ol></li><li>空间整合：<ol><li>CMS 会出现碎片化的问题，通常的在几次 FGC 后进行内存整理。</li><li>G1 划分为多个 Region，以 Region 为单位，Region 之间存在复制算法。在整个看来是一个标记压缩算法，因此不会因为再放入大对象时找不到连续的空间而提前进入 GC，尤其当 Java 堆非常大的时候，G1 优势就会更加明显。</li></ol></li><li>可预测的停顿时间模型：<ol><li>G1 可以只选取部分 Regin 进行内存回收，缩小了选取范围，因此全局停顿得到很好的控制。</li><li>G1 跟踪 Regin 里面的垃圾堆积价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Regin。保证 G1 收集器在有限时间内可以获取尽可能高的收集效率。</li></ol></li><li>参数设置：<ol><li><code>-XX:+UseG1GC</code>.</li><li><code>-XX:G1HeapRegionSize</code>设置每个 Region 的大小，值为 2 的次幂，1Mb-32Mb 区间，一般会划分为 2048，默认是堆的 1&#x2F;2000。</li><li><code>-XX:MaxGCPauseMillis</code>最大可停顿时间，默认 200ms。</li><li><code>-XX:ParallelGCThread</code>设置 STW 工作线程数，最多为 8。</li><li><code>-XX:ConcGCThreads</code>设置并发标记的线程数，将 n 设置为 ParallelGCThread 的 1&#x2F;4。</li><li><code>-XX:InitatingHeapOccupancyPercent</code>设置触发并发 GC 周期的 Java 堆占用率阈值，超过阈值触发 GC，默认 45%。</li></ol></li><li>G1 调优：<ol><li>开启 G1 垃圾回收器<code>-XX:+UseG1GC</code>。</li><li>设置堆的最大内存<code>-Xms -Xmx</code>。</li><li>设置最大停顿时间。</li></ol></li></ol><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><ol><li>G1 收集器将堆中空间分为若干个 Region，每个 Region 代表着不同的身份，分别是伊甸园区、幸存者 0 区、幸存者 1 区以及老年代，使其在逻辑上是连续的。假如在 Eden 占领 Region 的情况下是不可能将存放在老年代的对象放入的，也就是不可能出现身份变化的，只有在 Region 被全部释放时才会被赋有新的身份。</li></ol><p><img src="/mimi-blog/image/1725616981969-ff48f345-3905-40b6-8fcf-70fc8414aae6.png"></p><ol start="2"><li>在 G1 中出现大对象的概念是因为在之前的分代思想中，如果出现大对象将直接放入老年代中，而这个大对象又不经常使用，可以在一定程度上说是内存泄漏了，所以出现了大对象的概念（如果一个 Region 不够放下一个对象，此时就称为大对象）。</li></ol><h3 id="G1-的收集过程"><a href="#G1-的收集过程" class="headerlink" title="G1 的收集过程"></a>G1 的收集过程</h3><ol><li>G1 垃圾回收过程包括以下三个环节：<ol><li>YGC</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ol></li></ol><h3 id="记忆集、卡表"><a href="#记忆集、卡表" class="headerlink" title="记忆集、卡表"></a>记忆集、卡表</h3><h2 id="G1-年轻代"><a href="#G1-年轻代" class="headerlink" title="G1 -年轻代"></a>G1 -年轻代</h2><ol><li>JVM 启动时，G1 准备好 Eden 区，程序运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次 YGC 回收过程。</li><li>年轻代垃圾回收只会回收 Eden 和 S0.1。</li><li>YGC 进行时首先停止应用程序的执行 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;STW&lt;/font&gt;</code>，G1 创建回收集（<code>&lt;font style=&quot;color:#ED740C;&quot;&gt;Collection Set&lt;/font&gt;</code>），回收集指需要被回收的内存分段的集合，年轻代回收过程的回收集包括年轻代 <code>&lt;font style=&quot;color:#ED740C;&quot;&gt;Eden 和幸 Survivor 区所有的内存分段&lt;/font&gt;</code>。</li></ol><p><img src="/mimi-blog/image/1725622765243-cd307670-119a-4541-929a-43d088196f35.png"></p><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><ol><li>扫描根，根指的是 static 变量指向的对象，正在执行的方法表用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li><li>更新 RSet，处理 dirty card queue 中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反应老年代对所有内存分段中的对象的引用。</li><li>处理 RSet，识别被老年代引用的对象（Eden），这些被指向的 Eden 中的对象被认为是存活对象。</li><li>复制对象，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达到阈值，年龄会+1，达到阈值就会被复制到 Old 区中空的内存分段。如果 Survivor 空间不足，Eden 空间的部分数据会直接晋升到老年代。</li><li>处理引用：处理 强软弱徐引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果。</li></ol><h3 id="并发标记过程"><a href="#并发标记过程" class="headerlink" title="并发标记过程"></a>并发标记过程</h3><ol><li>初始标记阶段：对根节点的直接可达对象进行标记（STW），且触发一次 YGC。</li><li>根区域扫描：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象，这一过程必须要 YGC 之前完成。</li><li>并发标记：对整个堆进行标记，此过程可能被 YGC 中断。在并发标记阶段，若发现 Region 都是垃圾，则立即回收，也叫做实时回收。并发标记过程中会计算每个 Region 的对象活性（存活比例）。</li><li>再次标记：由于是并行进行，所以需要再次修正上一次的标记结果（STW）。G1 中采用了比 CMS 更快的初始快照算法（SATB）。</li><li>独占清理：计算 Region 的存活对象和 GC 回收比例，进行排序，识别可混合回收的 Region，为下阶段做铺垫（STW）。</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h3><ol><li>标记结束后，Region 中百分百为垃圾的区域已经被回收掉了，Region 存在部分垃圾的被计算出来。默认老年代内存被分段为 8 次被回收（<code>-XX:G1MixedGCCountTarget</code>设置分段）。</li><li>混合回收的会收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段、幸存者区内存分。</li><li>G1 会优先回收 Region 活性较低的区域（垃圾对象越多越先被回收）<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%。</li><li><code>-XX:G1HeapWastePercent</code>默认值为 10%，允许整个堆中有百分之十的浪费，如果低于这个阈值，则不再进行混合回收。</li></ol><p><img src="/mimi-blog/image/1725625107989-8b5ce144-f175-4d36-85f7-7f95df3182ba.png"></p><h2 id="常用-GC-参数设置"><a href="#常用-GC-参数设置" class="headerlink" title="常用 GC 参数设置"></a>常用 GC 参数设置</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>知识库</tag>
      
      <tag>Java高级</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>498. LeetCode</title>
    <link href="/mimi-blog/2024/10/15/498LeetCode/"/>
    <url>/mimi-blog/2024/10/15/498LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对角线遍历"><a href="#1-对角线遍历" class="headerlink" title="1. 对角线遍历"></a>1. 对角线遍历</h1><ol><li><p><code>数组</code> + <code>模拟</code></p></li><li><p>处理好边界即可。</p></li><li><p>定义一个 flag 变量，表示向上（true）还是向下（false）。</p></li><li><ol><li>遍历时只关注是否到达边界，到达边界则做 i 和 j 的改变，否则（向上时<code>i--  j++</code>；向下时<code>j++ i--</code>）。</li><li>向上时的边界条件<code>i - 1 &lt; 0 || j + 1 &lt; mat[0].length</code>。</li></ol></li><li><ol><li><ol><li>到达边界时就<code>i++</code>，这里也要分情况如果 <code>i++</code>超出了则说明我们到了矩阵的下半部分，只需要将<code>i++</code>变为<code>j++</code>即可。</li></ol></li></ol></li><li><ol><li>向下时的边界条件<code>i + 1 &gt; mat.length || j - 1 &lt; 0</code>。</li></ol></li><li><ol><li><ol><li>到达边界时就<code>j++</code>，同上<code>j++</code>超出就将<code>j++</code>变为<code>i++</code>。</li></ol></li></ol></li></ol><p><img src="/mimi-blog/image/20241015204708.png" alt="20241015204708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findDiagonalOrder(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mat.length * mat[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i != mat.length - <span class="hljs-number">1</span> || j != mat[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    res[index++] = mat[i][j];<br>                    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> || j + <span class="hljs-number">1</span> &gt;= mat[<span class="hljs-number">0</span>].length) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    i--;<br>                    j++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; mat[<span class="hljs-number">0</span>].length) &#123;<br>                    j++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    i++;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    res[index++] = mat[i][j];<br>                    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= mat.length || j - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    i++;<br>                    j--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; mat.length) &#123;<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    j++;<br>                &#125;<br>            &#125;<br>            flag = !flag;<br>        &#125;<br>        res[index] = mat[mat.length - <span class="hljs-number">1</span>][mat[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
